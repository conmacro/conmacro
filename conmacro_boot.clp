(deffunction ignore (?v )
nil)
(deffunction str-endswithp (?str ?ending )
(eq (sub-string (+ 1 (- (str-length ?str) (str-length ?ending))) (str-length ?str) ?str) ?ending)))
(defgeneric to-verbatim)
(defmethod to-verbatim ((?s SYMBOL (eq ?s nil)) ?type )
"")
(defmethod to-verbatim ((?s STRING) ?type )
?s)
(defmethod to-verbatim ((?f (multifieldp ?f)) ?type )
(bind ?s "")
   (loop-for-count (?i (length$ ?f))
      (bind ?s (str-cat ?s (to-verbatim (nth$ ?i ?f) ?type))))
   ?s))
(deftemplate clips:generic 
(slot name)
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:generic)) (?type (eq ?type clips-source-code)) )
(format nil "(defgeneric %s)%n" (fact-slot-value ?f name))))
(deffunction clips-function-to-source-code-verbatim (?name ?f ?type )
(bind ?s (format nil "(def%s %s (" ?name (fact-slot-value ?f name)))
    (bind ?args (fact-slot-value ?f arguments))
    (loop-for-count (?i (length$ ?args))
       (bind ?s (str-cat ?s (to-verbatim (nth$ ?i ?args) ?type) " ")))
    (bind ?s (str-cat ?s (format nil ")%n%s)%n" (to-verbatim (fact-slot-value ?f body) ?type))))
    ?s))
(deftemplate clips:method 
(slot name)
(multislot arguments)
(slot body)
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:method)) (?type (eq ?type clips-source-code)) )
(clips-function-to-source-code-verbatim method ?f ?type))
(deftemplate clips:function 
(slot name)
(multislot arguments)
(slot body)
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:function)) (?type (eq ?type clips-source-code)) )
(clips-function-to-source-code-verbatim function ?f ?type))
(deftemplate clips:rule 
(slot name)
(multislot conditions)
(slot body)
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:rule)) (?type (eq ?type clips-source-code)) )
(bind ?s (format nil "(defrule %s%n" (fact-slot-value ?f name)))
    (bind ?conds (fact-slot-value ?f conditions))
    (loop-for-count (?i (length$ ?conds))
       (bind ?s (str-cat ?s (to-verbatim (nth$ ?i ?conds) ?type) (format nil "%n"))))
    (bind ?s (str-cat ?s (format nil " =>%n %s)%n" (to-verbatim (fact-slot-value ?f body) ?type))))
    ?s))
(deftemplate clips:template 
(slot name)
)
(deftemplate clips:template-slot 
(slot template)
(slot name)
(slot default)
(slot multi (default FALSE))
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:template)) (?type (eq ?type clips-source-code)) )
(bind ?s (format nil "(deftemplate %s %n" (fact-slot-value ?f name)))
    (do-for-all-facts ((?slot clips:template-slot)) (eq ?slot:template ?f)
       (bind ?s (str-cat ?s (to-verbatim ?slot ?type))))
    (format nil "%s)%n" ?s)))
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:template-slot)) (?type (eq ?type clips-source-code)) )
(bind ?multi (if (fact-slot-value ?f multi) then "multi" else ""))
(bind ?default (if (eq nil (fact-slot-value ?f default)) then "" else (format nil " (default %s)" (fact-slot-value ?f default)))) 
    (format nil "(%sslot %s%s)%n" ?multi (fact-slot-value ?f name) ?default)))
(deftemplate clips:assertion 
(slot is)
)
(defmethod to-verbatim ((?f FACT-ADDRESS (eq (fact-relation ?f) clips:assertion)) (?type (eq ?type clips-source-code)) )
(format nil "(assert %s)%n" (to-verbatim (fact-slot-value ?f is) ?type)))
(deftemplate file 
(slot name)
(multislot is)
)
(deftemplate file-type 
(slot file)
(slot is)
)
(deftemplate file-extension 
(slot is)
(slot assumed-type)
)
(assert (file-extension (is "clp") (assumed-type clips-source-code)))
(assert (file-extension (is "md") (assumed-type markdown)))
(defrule file-type-mapping
(file-extension (is ?ext) (assumed-type ?type))
?file <- (file (name ?name&:(str-endswithp ?name (str-cat "." ?ext))))
(not (exists (file-type (file ?file))))
 =>
 (assert (file-type (file ?file) (is ?type))))
(deftemplate file-content 
(slot file)
(slot is)
)
(defrule produce-file-content
?file <- (file (name ?name) (is $?data))
(file-type (file ?file) (is ?type))
 =>
 (assert (file-content (file ?file) (is (to-verbatim ?data ?type)))))
(defrule write-file
?file <- (file (name ?name))
(file-content (file ?file) (is ?content))
 =>
 (bind ?logicalName (gensym))
    (open ?name ?logicalName "wb")
    (printout ?logicalName ?content)
    (close ?name))
